/*
 * Copyright (C) 2025 Connor Nolan connor@cnolandev.com
 *
 * This file is part of the Semikit project.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import type { TileModel } from "../models/TileModel.js";
import type { PaletteModel } from "../models/PaletteModel.js";

/**
 * ExportManager - Utility for exporting tile and palette data
 *
 * Handles exporting to various formats:
 * - Binary (.bin) - Raw planar tile data
 * - Palette (.pal) - RGB555 palette data
 * - C header (.h) - C/C++ header files
 * - Assembly (.asm) - Assembly data files
 */
export class ExportManager {
  /**
   * Export tile to binary format (32 bytes, 4bpp planar)
   */
  static exportTileBinary(tile: TileModel): Uint8Array {
    return tile.exportPlanar();
  }

  /**
   * Export palette to binary format (512 bytes, RGB555)
   */
  static exportPaletteBinary(palette: PaletteModel): Uint8Array {
    return palette.exportBinary();
  }

  /**
   * Generate C header for tile data
   */
  static generateTileCHeader(tile: TileModel, name: string = "tile"): string {
    const data = tile.exportPlanar();
    const variableName = this.sanitizeName(name);

    let header = `// Tile data: ${name}\n`;
    header += `// 8x8 pixels, 4bpp planar format (32 bytes)\n`;
    header += `// Generated by Semitile\n\n`;
    header += `#ifndef TILE_${variableName.toUpperCase()}_H\n`;
    header += `#define TILE_${variableName.toUpperCase()}_H\n\n`;
    header += `const unsigned char ${variableName}[32] = {\n`;

    // Format as 8 bytes per line (one row per plane section)
    for (let i = 0; i < 4; i++) {
      header += `    // Plane ${i}\n    `;
      for (let j = 0; j < 8; j++) {
        const byte = data[i * 8 + j];
        header += `0x${byte.toString(16).toUpperCase().padStart(2, "0")}`;
        if (i < 3 || j < 7) header += ", ";
      }
      header += "\n";
    }

    header += `};\n\n`;
    header += `#endif // TILE_${variableName.toUpperCase()}_H\n`;

    return header;
  }

  /**
   * Generate C header for palette data
   */
  static generatePaletteCHeader(
    palette: PaletteModel,
    name: string = "palette",
  ): string {
    const data = palette.exportBinary();
    const variableName = this.sanitizeName(name);

    let header = `// Palette data: ${name}\n`;
    header += `// 256 colors (16 sub-palettes × 16 colors), RGB555 format (512 bytes)\n`;
    header += `// Generated by Semitile\n\n`;
    header += `#ifndef PALETTE_${variableName.toUpperCase()}_H\n`;
    header += `#define PALETTE_${variableName.toUpperCase()}_H\n\n`;
    header += `const unsigned short ${variableName}[256] = {\n`;

    // Format as 8 colors per line
    for (let subPal = 0; subPal < 16; subPal++) {
      header += `    // Sub-palette ${subPal}\n`;
      for (let row = 0; row < 2; row++) {
        header += `    `;
        for (let col = 0; col < 8; col++) {
          const colorIdx = subPal * 16 + row * 8 + col;
          const offset = colorIdx * 2;
          const low = data[offset];
          const high = data[offset + 1];
          const rgb555 = (high << 8) | low;

          header += `0x${rgb555.toString(16).toUpperCase().padStart(4, "0")}`;
          if (subPal < 15 || row < 1 || col < 7) header += ", ";
        }
        header += "\n";
      }
    }

    header += `};\n\n`;
    header += `#endif // PALETTE_${variableName.toUpperCase()}_H\n`;

    return header;
  }

  /**
   * Generate Assembly file for tile data
   */
  static generateTileASM(tile: TileModel, name: string = "tile"): string {
    const data = tile.exportPlanar();
    const labelName = this.sanitizeName(name);

    let asm = `; Tile data: ${name}\n`;
    asm += `; 8x8 pixels, 4bpp planar format (32 bytes)\n`;
    asm += `; Generated by Semitile\n\n`;
    asm += `${labelName}:\n`;

    // Format as 8 bytes per line
    for (let i = 0; i < 4; i++) {
      asm += `    ; Plane ${i}\n`;
      asm += `    .byte `;
      for (let j = 0; j < 8; j++) {
        const byte = data[i * 8 + j];
        asm += `$${byte.toString(16).toUpperCase().padStart(2, "0")}`;
        if (j < 7) asm += ", ";
      }
      asm += "\n";
    }

    return asm;
  }

  /**
   * Generate Assembly file for palette data
   */
  static generatePaletteASM(
    palette: PaletteModel,
    name: string = "palette",
  ): string {
    const data = palette.exportBinary();
    const labelName = this.sanitizeName(name);

    let asm = `; Palette data: ${name}\n`;
    asm += `; 256 colors (16 sub-palettes × 16 colors), RGB555 format (512 bytes)\n`;
    asm += `; Generated by Semitile\n\n`;
    asm += `${labelName}:\n`;

    // Format as 8 colors per line
    for (let subPal = 0; subPal < 16; subPal++) {
      asm += `    ; Sub-palette ${subPal}\n`;
      for (let row = 0; row < 2; row++) {
        asm += `    .word `;
        for (let col = 0; col < 8; col++) {
          const colorIdx = subPal * 16 + row * 8 + col;
          const offset = colorIdx * 2;
          const low = data[offset];
          const high = data[offset + 1];
          const rgb555 = (high << 8) | low;

          asm += `$${rgb555.toString(16).toUpperCase().padStart(4, "0")}`;
          if (col < 7) asm += ", ";
        }
        asm += "\n";
      }
    }

    return asm;
  }

  /**
   * Trigger browser download of a file
   */
  static downloadFile(
    data: Uint8Array | string,
    filename: string,
    mimeType: string = "application/octet-stream",
  ): void {
    const blob =
      typeof data === "string"
        ? new Blob([data], { type: "text/plain" })
        : new Blob([data], { type: mimeType });

    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Sanitize name for use as variable/label name
   */
  private static sanitizeName(name: string): string {
    // Remove file extension if present
    name = name.replace(/\.[^.]+$/, "");

    // Replace non-alphanumeric characters with underscores
    name = name.replace(/[^a-zA-Z0-9_]/g, "_");

    // Ensure it doesn't start with a number
    if (/^[0-9]/.test(name)) {
      name = "_" + name;
    }

    return name || "data";
  }
}
