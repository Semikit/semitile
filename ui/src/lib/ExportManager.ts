/*
 * Copyright (C) 2025 Connor Nolan connor@cnolandev.com
 *
 * This file is part of the Semikit project.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import type { TileModel } from "../models/TileModel.js";
import type { PaletteModel } from "../models/PaletteModel.js";
import type { TilemapModel } from "../models/TilemapModel.js";
import type { TileBankModel } from "../models/TileBankModel.js";

/**
 * ExportManager - Utility for exporting tile and palette data
 *
 * Handles exporting to various formats:
 * - Binary (.bin) - Raw planar tile data
 * - Palette (.pal) - RGB555 palette data
 * - C header (.h) - C/C++ header files
 * - Assembly (.asm) - Assembly data files
 * - PNG (.png) - Tilemap as PNG image
 */
export class ExportManager {
  /**
   * Export tile to binary format (32 bytes, 4bpp planar)
   */
  static exportTileBinary(tile: TileModel): Uint8Array {
    return tile.exportPlanar();
  }

  /**
   * Export palette to binary format (512 bytes, RGB555)
   */
  static exportPaletteBinary(palette: PaletteModel): Uint8Array {
    return palette.exportBinary();
  }

  /**
   * Generate C header for tile data
   */
  static generateTileCHeader(tile: TileModel, name: string = "tile"): string {
    const data = tile.exportPlanar();
    const variableName = this.sanitizeName(name);

    let header = `// Tile data: ${name}\n`;
    header += `// 8x8 pixels, 4bpp planar format (32 bytes)\n`;
    header += `// Generated by Semitile\n\n`;
    header += `#ifndef TILE_${variableName.toUpperCase()}_H\n`;
    header += `#define TILE_${variableName.toUpperCase()}_H\n\n`;
    header += `const unsigned char ${variableName}[32] = {\n`;

    // Format as 8 bytes per line (one row per plane section)
    for (let i = 0; i < 4; i++) {
      header += `    // Plane ${i}\n    `;
      for (let j = 0; j < 8; j++) {
        const byte = data[i * 8 + j];
        header += `0x${byte.toString(16).toUpperCase().padStart(2, "0")}`;
        if (i < 3 || j < 7) header += ", ";
      }
      header += "\n";
    }

    header += `};\n\n`;
    header += `#endif // TILE_${variableName.toUpperCase()}_H\n`;

    return header;
  }

  /**
   * Generate C header for palette data
   */
  static generatePaletteCHeader(
    palette: PaletteModel,
    name: string = "palette",
  ): string {
    const data = palette.exportBinary();
    const variableName = this.sanitizeName(name);

    let header = `// Palette data: ${name}\n`;
    header += `// 256 colors (16 sub-palettes × 16 colors), RGB555 format (512 bytes)\n`;
    header += `// Generated by Semitile\n\n`;
    header += `#ifndef PALETTE_${variableName.toUpperCase()}_H\n`;
    header += `#define PALETTE_${variableName.toUpperCase()}_H\n\n`;
    header += `const unsigned short ${variableName}[256] = {\n`;

    // Format as 8 colors per line
    for (let subPal = 0; subPal < 16; subPal++) {
      header += `    // Sub-palette ${subPal}\n`;
      for (let row = 0; row < 2; row++) {
        header += `    `;
        for (let col = 0; col < 8; col++) {
          const colorIdx = subPal * 16 + row * 8 + col;
          const offset = colorIdx * 2;
          const low = data[offset];
          const high = data[offset + 1];
          const rgb555 = (high << 8) | low;

          header += `0x${rgb555.toString(16).toUpperCase().padStart(4, "0")}`;
          if (subPal < 15 || row < 1 || col < 7) header += ", ";
        }
        header += "\n";
      }
    }

    header += `};\n\n`;
    header += `#endif // PALETTE_${variableName.toUpperCase()}_H\n`;

    return header;
  }

  /**
   * Generate Assembly file for tile data
   */
  static generateTileASM(tile: TileModel, name: string = "tile"): string {
    const data = tile.exportPlanar();
    const labelName = this.sanitizeName(name);

    let asm = `; Tile data: ${name}\n`;
    asm += `; 8x8 pixels, 4bpp planar format (32 bytes)\n`;
    asm += `; Generated by Semitile\n\n`;
    asm += `${labelName}:\n`;

    // Format as 8 bytes per line
    for (let i = 0; i < 4; i++) {
      asm += `    ; Plane ${i}\n`;
      asm += `    .byte `;
      for (let j = 0; j < 8; j++) {
        const byte = data[i * 8 + j];
        asm += `$${byte.toString(16).toUpperCase().padStart(2, "0")}`;
        if (j < 7) asm += ", ";
      }
      asm += "\n";
    }

    return asm;
  }

  /**
   * Generate Assembly file for palette data
   */
  static generatePaletteASM(
    palette: PaletteModel,
    name: string = "palette",
  ): string {
    const data = palette.exportBinary();
    const labelName = this.sanitizeName(name);

    let asm = `; Palette data: ${name}\n`;
    asm += `; 256 colors (16 sub-palettes × 16 colors), RGB555 format (512 bytes)\n`;
    asm += `; Generated by Semitile\n\n`;
    asm += `${labelName}:\n`;

    // Format as 8 colors per line
    for (let subPal = 0; subPal < 16; subPal++) {
      asm += `    ; Sub-palette ${subPal}\n`;
      for (let row = 0; row < 2; row++) {
        asm += `    .word `;
        for (let col = 0; col < 8; col++) {
          const colorIdx = subPal * 16 + row * 8 + col;
          const offset = colorIdx * 2;
          const low = data[offset];
          const high = data[offset + 1];
          const rgb555 = (high << 8) | low;

          asm += `$${rgb555.toString(16).toUpperCase().padStart(4, "0")}`;
          if (col < 7) asm += ", ";
        }
        asm += "\n";
      }
    }

    return asm;
  }

  /**
   * Export tilemap as PNG image
   *
   * @param tilemapModel The tilemap to export
   * @param tileBankModel The tile bank containing the tiles
   * @param paletteModel The palette for rendering colors
   * @param pixelSize Pixels per tile pixel (default: 1 for 8x8 pixels per tile)
   * @returns Promise that resolves to a Blob containing the PNG data
   */
  static async exportTilemapPNG(
    tilemapModel: TilemapModel,
    tileBankModel: TileBankModel,
    paletteModel: PaletteModel,
    pixelSize: number = 1,
  ): Promise<Blob> {
    const width = tilemapModel.getWidth();
    const height = tilemapModel.getHeight();
    const tileSize = 8 * pixelSize;

    // Create off-screen canvas
    const canvas = document.createElement("canvas");
    canvas.width = width * tileSize;
    canvas.height = height * tileSize;

    const ctx = canvas.getContext("2d", { alpha: false });
    if (!ctx) {
      throw new Error("Failed to get canvas context");
    }

    // Clear canvas with background color
    ctx.fillStyle = "#1a1a2e";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Render all tiles
    for (let ty = 0; ty < height; ty++) {
      for (let tx = 0; tx < width; tx++) {
        const entry = tilemapModel.getEntry(tx, ty);
        if (!entry) continue;

        const tile = tileBankModel.getTile(entry.tileIndex);
        if (!tile) continue;

        const screenX = tx * tileSize;
        const screenY = ty * tileSize;

        // Use ImageData for efficient rendering
        const imageData = ctx.createImageData(tileSize, tileSize);
        const data = imageData.data;

        for (let py = 0; py < 8; py++) {
          for (let px = 0; px < 8; px++) {
            // Apply flips if needed
            const actualPx = entry.hFlip ? (7 - px) : px;
            const actualPy = entry.vFlip ? (7 - py) : py;

            const colorIndex = tile.getPixel(actualPx, actualPy);
            const color = paletteModel.getColor(entry.paletteIdx, colorIndex);

            // Fill the pixel block in ImageData
            const startPixelX = px * pixelSize;
            const startPixelY = py * pixelSize;
            const endPixelX = (px + 1) * pixelSize;
            const endPixelY = (py + 1) * pixelSize;

            for (let y = startPixelY; y < endPixelY; y++) {
              for (let x = startPixelX; x < endPixelX; x++) {
                const idx = (y * tileSize + x) * 4;
                data[idx] = color.r;
                data[idx + 1] = color.g;
                data[idx + 2] = color.b;
                data[idx + 3] = 255; // Alpha
              }
            }
          }
        }

        ctx.putImageData(imageData, screenX, screenY);
      }
    }

    // Convert canvas to PNG blob
    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error("Failed to create PNG blob"));
          }
        },
        "image/png"
      );
    });
  }

  /**
   * Trigger browser download of a file
   */
  static downloadFile(
    data: Uint8Array | string,
    filename: string,
    mimeType: string = "application/octet-stream",
  ): void {
    const blob =
      typeof data === "string"
        ? new Blob([data], { type: "text/plain" })
        : new Blob([data as BlobPart], { type: mimeType });

    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Trigger browser download of a Blob
   */
  static downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Sanitize name for use as variable/label name
   */
  private static sanitizeName(name: string): string {
    // Remove file extension if present
    name = name.replace(/\.[^.]+$/, "");

    // Replace non-alphanumeric characters with underscores
    name = name.replace(/[^a-zA-Z0-9_]/g, "_");

    // Ensure it doesn't start with a number
    if (/^[0-9]/.test(name)) {
      name = "_" + name;
    }

    return name || "data";
  }
}
